#pragma kernel CalculateExternalForces
#pragma kernel PredictPositions
#pragma kernel SortParticlesByHash
#pragma kernel BuildHashOffsetTable
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions

static const uint MAX_UINT = 4294967295;
static const int NumThreads = 64;

// Kernel Constants (set from C# via compute.SetFloat)
float Poly6ScalingFactor;
float SpikyPow3ScalingFactor;
float SpikyPow2ScalingFactor;
float SpikyPow3DerivativeScalingFactor;
float SpikyPow2DerivativeScalingFactor;

// Buffers
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> Densities;

RWStructuredBuffer<uint> ParticleHashTable;
RWStructuredBuffer<uint> HashOffsetTable;


// Simulation Settings (set from C#)
uint numParticles;
float gravity;
float timeStep;
float collisionDamping;
float smoothingRadius;
float targetDensity;
float pressureMultiplier;
float nearPressureMultiplier;
float viscosityStrength;
float2 boundsSize;
uint hashTableSize;

// Kernel Functions
float Poly6Kernel(float distance, float radius)
{
	if (distance >= radius)
		return 0;
	float v = radius * radius - distance * distance;
	return v * v * v * Poly6ScalingFactor;
}

float Pow3Kernel(float distance, float radius)
{
	if (distance >= radius)
		return 0;
	float v = radius - distance;
	return v * v * v * SpikyPow3ScalingFactor;
}

float Pow2Kernel(float distance, float radius)
{
	if (distance >= radius)
		return 0;
	float v = radius - distance;
	return v * v * SpikyPow2ScalingFactor;
}

float Pow3KernelGradient(float distance, float radius)
{
	if (distance > radius)
		return 0;
	float v = radius - distance;
	return -v * v * SpikyPow3DerivativeScalingFactor;
}

float Pow2KernelGradient(float distance, float radius)
{
	if (distance > radius)
		return 0;
	float v = radius - distance;
	return -v * SpikyPow2DerivativeScalingFactor;
}

// Kernel Wrappers

float DensityKernel(float distance, float radius)
{
	return Pow2Kernel(distance, radius);
}

float NearDensityKernel(float distance, float radius)
{
	return Pow3Kernel(distance, radius);
}

float DensityDerivative(float distance, float radius)
{
	return Pow2KernelGradient(distance, radius);
}

float NearDensityDerivative(float distance, float radius)
{
	return Pow3KernelGradient(distance, radius);
}

float ViscosityKernel(float distance, float radius)
{
	return Poly6Kernel(distance, radius);
}


//Simulation Functions
float2 CalculateDensity(float2 position)
{
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	for (int secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
	{
			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
			float2 vectorToSecondParticle = secondParticlePosition - position;
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

			if (sqrDstToSecondParticle > sqrSmoothingRadius)
				continue;

			float dst = sqrt(sqrDstToSecondParticle);
			density += DensityKernel(dst, smoothingRadius);
			nearDensity += NearDensityKernel(dst, smoothingRadius);
	}

	return float2(density, nearDensity);
}

float PressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
	return nearPressureMultiplier * nearDensity;
}

float2 ExternalForces(float2 pos, float2 velocity)
{
	// Gravity
	return float2(0, gravity);
}


void HandleCollisions(uint particleIndex)
{
	float2 pos = Positions[particleIndex];
	float2 vel = Velocities[particleIndex];

	const float2 halfSize = boundsSize * 0.5;
	float2 edgeDst = halfSize - abs(pos);

	if (edgeDst.x <= 0)
	{
		pos.x = halfSize.x * sign(pos.x);
		vel.x *= -1 * collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		pos.y = halfSize.y * sign(pos.y);
		vel.y *= -1 * collisionDamping;
	}

	Positions[particleIndex] = pos;
	Velocities[particleIndex] = vel;
}

float GetHash(int2 cellIndex)
{
	return ((cellIndex.x * 73856093) ^ (cellIndex.y * 19349663)) % hashTableSize;
}

void GetNeighbouringCellHashes(uint2 cellIndex, out uint results[9])
{
	uint offsets[] = {
		-1, -1,
		-1, 0,
		-1, 1,
		 0, -1,
		 0, 0,
		 0, 1,
		 1, -1,
		 1, 0,
		 1, 1
	};
	
    uint idx = 0;
    for (int i = 0; i < 9; i++)
    {	
        results[idx] = MAX_UINT;
        uint hash = GetHash(cellIndex + int2(offsets[i * 2], offsets[i * 2 + 1]));
        bool found = false;
        for (int j = 0; j < i; j++)
        {
			if (results[j] == hash)
			{
				found = true;
				break;
            }
        }
        if (!found)
        {
            results[idx] = hash;
            idx++;
        }
    }
}

//GPU Kernels
[numthreads(NumThreads, 1, 1)]
void CalculateExternalForces(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	Velocities[id.x] += ExternalForces(Positions[id.x], Velocities[id.x]) * timeStep;
}

[numthreads(NumThreads, 1, 1)]
void PredictPositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	const float predictionStep = 1 / 120.0;
	PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * predictionStep;
	
	int2 cellIndex = int2(floor(PredictedPositions[id.x] / smoothingRadius));
	ParticleHashTable[id.x] = GetHash(cellIndex);
	
}

uint sortingDistance;
uint sortingGroupSize;
[numthreads(NumThreads, 1, 1)]
void SortParticlesByHash(uint3 id : SV_DispatchThreadID)
{
	uint partnerId = id.x ^ sortingDistance;
	bool ascending = ((id.x & sortingGroupSize) == 0);
	bool doSwap = (ascending && (ParticleHashTable[id.x] > ParticleHashTable[partnerId])) || (!ascending && (ParticleHashTable[id.x]  < ParticleHashTable[partnerId]));
	if (doSwap && partnerId > id.x && partnerId < numParticles)
	{
		uint tempUint = ParticleHashTable[id.x];
		ParticleHashTable[id.x] = ParticleHashTable[partnerId];
        ParticleHashTable[partnerId] = tempUint;
		//i dont think densisties need to be swapped
        //float2 tempFloat2 = Densities[id.x];
		//Densities[id.x] = Densities[partnerId];
		//Densities[partnerId] = tempFloat2;
		
        float2 tempFloat2 = Positions[id.x];
        Positions[id.x] = Positions[partnerId];
		Positions[partnerId] = tempFloat2;
		
		tempFloat2 = PredictedPositions[id.x];
        PredictedPositions[id.x] = PredictedPositions[partnerId];
        PredictedPositions[partnerId] = tempFloat2;
		
		tempFloat2 = Velocities[id.x];
		Velocities[id.x] = Velocities[partnerId];
        Velocities[partnerId] = tempFloat2;
    }
}

[numthreads(NumThreads,1,1)]
void BuildHashOffsetTable(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= hashTableSize)
		return;
	for(uint i = 0; i < numParticles; i++)
	{
		if (ParticleHashTable[i] == id.x)
		{
			HashOffsetTable[id.x] = i;
			return;
		}
	}
    HashOffsetTable[id.x] = numParticles;
}

[numthreads(NumThreads, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	float2 position = PredictedPositions[id.x];
    float sqrSmoothingRadius = smoothingRadius * smoothingRadius;
    float density = 0;
    float nearDensity = 0;

    int2 cellIndex = int2(floor(position / smoothingRadius));
    uint neighborHashes[9];
    GetNeighbouringCellHashes(uint2(cellIndex), neighborHashes);
	
    for (int i = 0; i < 9; i++)
    {
        uint currentHash = neighborHashes[i];
        if (currentHash == MAX_UINT)
            break;
        for (uint startIndex = HashOffsetTable[currentHash]; startIndex < numParticles && ParticleHashTable[startIndex] == currentHash; startIndex++)
        {
            if (startIndex == id.x)
                continue;
            float2 secondParticlePosition = PredictedPositions[startIndex];
            float2 vectorToSecondParticle = secondParticlePosition - position;
            float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

            if (sqrDstToSecondParticle > sqrSmoothingRadius)
                continue;

            float dst = sqrt(sqrDstToSecondParticle);
            density += DensityKernel(dst, smoothingRadius);
            nearDensity += NearDensityKernel(dst, smoothingRadius);
        }
    }
    /*for (int secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
    {
        float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
        float2 vectorToSecondParticle = secondParticlePosition - position;
        float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

        if (sqrDstToSecondParticle > sqrSmoothingRadius)
            continue;

        float dst = sqrt(sqrDstToSecondParticle);
        density += DensityKernel(dst, smoothingRadius);
        nearDensity += NearDensityKernel(dst, smoothingRadius);
    }*/

    Densities[id.x] =  float2(density, nearDensity);
}

[numthreads(NumThreads, 1, 1)]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = PressureFromDensity(density);
	float nearPressure = NearPressureFromDensity(densityNear);
	float2 pressureForce = 0;
	
	float2 position = PredictedPositions[id.x];
    int2 cellIndex = int2(floor(position / smoothingRadius));
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;
	
    uint neighborHashes[9];
    GetNeighbouringCellHashes(uint2(cellIndex), neighborHashes);
	
    for (int i = 0; i < 9; i++)
    {
        uint currentHash = neighborHashes[i];
        if (currentHash == MAX_UINT)
            break;
        for (uint startIndex = HashOffsetTable[currentHash]; startIndex < numParticles && ParticleHashTable[startIndex] == currentHash; startIndex++)
        {
            if (startIndex == id.x)
                continue;

            float2 secondParticlePosition = PredictedPositions[startIndex];
            float2 vectorToSecondParticle = secondParticlePosition - position;
            float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

            if (sqrDstToSecondParticle > sqrSmoothingRadius)
                continue;

            float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
            float2 interractionDirection = distanceToSecondParticle > 0 ? vectorToSecondParticle / distanceToSecondParticle : float2(0, 1);

            float secondParticlePressure = PressureFromDensity(Densities[startIndex][0]);
            float secondParticleNearPressure = NearPressureFromDensity(Densities[startIndex][1]);

            float sharedPressure = (pressure + secondParticlePressure) * 0.5;
            float sharedNearPressure = (nearPressure + secondParticleNearPressure) * 0.5;

            pressureForce += interractionDirection * DensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedPressure / Densities[startIndex][0];
            pressureForce += interractionDirection * NearDensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedNearPressure / Densities[startIndex][1];
        }

    }
	
    /*for (int offsetY = -1; offsetY <= 1; offsetY++)
    {
        for (int offsetX = -1; offsetX <= 1; offsetX++)
        {
            int2 neighborCellIndex = cellIndex + int2(offsetX, offsetY);
            uint neighborHash = GetHash(neighborCellIndex);
            for (uint startIndex = HashOffsetTable[neighborHash]; startIndex < numParticles && ParticleHashTable[startIndex] == neighborHash; startIndex++)
            {
                if (startIndex == id.x)
                    continue;

                float2 secondParticlePosition = PredictedPositions[startIndex];
                float2 vectorToSecondParticle = secondParticlePosition - position;
                float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

                if (sqrDstToSecondParticle > sqrSmoothingRadius)
                    continue;

                float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
                float2 interractionDirection = distanceToSecondParticle > 0 ? vectorToSecondParticle / distanceToSecondParticle : float2(0, 1);

                float secondParticlePressure = PressureFromDensity(Densities[startIndex][0]);
                float secondParticleNearPressure = NearPressureFromDensity(Densities[startIndex][1]);

                float sharedPressure = (pressure + secondParticlePressure) * 0.5;
                float sharedNearPressure = (nearPressure + secondParticleNearPressure) * 0.5;

                pressureForce += interractionDirection * DensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedPressure / Densities[startIndex][0];
                pressureForce += interractionDirection * NearDensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedNearPressure / Densities[startIndex][1];
            }
        }
    }*/

	/*for (uint secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
	{
			if (secondParticleIndex == id.x)
				continue;

			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
			float2 vectorToSecondParticle = secondParticlePosition - position;
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

			if (sqrDstToSecondParticle > sqrSmoothingRadius)
				continue;

			float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
			float2 interractionDirection = distanceToSecondParticle > 0 ? vectorToSecondParticle / distanceToSecondParticle : float2(0, 1);

			float secondParticlePressure = PressureFromDensity(Densities[secondParticleIndex][0]);
			float secondParticleNearPressure = NearPressureFromDensity(Densities[secondParticleIndex][1]);

			float sharedPressure = (pressure + secondParticlePressure) * 0.5;
			float sharedNearPressure = (nearPressure + secondParticleNearPressure) * 0.5;

			pressureForce += interractionDirection * DensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedPressure / Densities[secondParticleIndex][0];
			pressureForce += interractionDirection * NearDensityDerivative(distanceToSecondParticle, smoothingRadius) * sharedNearPressure / Densities[secondParticleIndex][1];
	}*/
	float2 acceleration = pressureForce / density;
	Velocities[id.x] += acceleration * timeStep;
}

[numthreads(NumThreads, 1, 1)]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;
	
	float2 position = PredictedPositions[id.x];
	float sqrSmoothingRadius = smoothingRadius * smoothingRadius;

	float2 viscosityForce = 0;
	float2 velocity = Velocities[id.x];

    int2 cellIndex = int2(floor(position / smoothingRadius));
	
    uint neighborHashes[9];
    GetNeighbouringCellHashes(uint2(cellIndex), neighborHashes);
	
    for (int i = 0; i < 9; i++)
    {
        uint currentHash = neighborHashes[i];
        if (currentHash == MAX_UINT)
            break;
        for (uint startIndex = HashOffsetTable[currentHash]; startIndex < numParticles && ParticleHashTable[startIndex] == currentHash; startIndex++)
        {
            if (startIndex == id.x)
                continue;
			
            float2 secondParticlePosition = PredictedPositions[startIndex];
            float2 vectorToSecondParticle = secondParticlePosition - position;
            float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

            if (sqrDstToSecondParticle > sqrSmoothingRadius)
                continue;

            float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
            float2 secondParticleVelocity = Velocities[startIndex];
            viscosityForce += (secondParticleVelocity - velocity) * ViscosityKernel(distanceToSecondParticle, smoothingRadius);
        }
    }
	
	/*for (uint secondParticleIndex = 0; secondParticleIndex < numParticles; secondParticleIndex++)
	{
			if (secondParticleIndex == id.x)
				continue;

			float2 secondParticlePosition = PredictedPositions[secondParticleIndex];
			float2 vectorToSecondParticle = secondParticlePosition - position;
			float sqrDstToSecondParticle = dot(vectorToSecondParticle, vectorToSecondParticle);

			if (sqrDstToSecondParticle > sqrSmoothingRadius)
				continue;

			float distanceToSecondParticle = sqrt(sqrDstToSecondParticle);
			float2 secondParticleVelocity = Velocities[secondParticleIndex];
			viscosityForce += (secondParticleVelocity - velocity) * ViscosityKernel(distanceToSecondParticle, smoothingRadius);
	}*/
	Velocities[id.x] += viscosityForce * viscosityStrength * timeStep;
}

[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles)
		return;

	Positions[id.x] += Velocities[id.x] * timeStep;
	HandleCollisions(id.x);
}